// This file was generated by Mendix Studio Pro.
//
// WARNING: Code you write here will be lost the next time you deploy the project.

package synthiaconnector.proxies.microflows;

import java.util.HashMap;
import java.util.Map;
import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;

public class Microflows
{
	/**
	 * @deprecated
	 * The default constructor of the Microflows class should not be used.
	 * Use the static microflow invocation methods instead.
	 */
	@java.lang.Deprecated(since = "9.12", forRemoval = true)
	public Microflows() {}

	// These are the microflows for the SynthiaConnector module
	/**
	 * Microflow can be used to invoke a chat completions API with a more complex request where a list of (historical) messages comprising the conversation so far is sent as part of the request.
	 * Inputs:
	 * - Request: Contains messages and optional attributes.
	 * - Connection: Configuration object that contains endpoint and API key. The SynthiaConnection specialization pointing to a ConfigurationTextGeneration must be passed.
	 */
	public static genaicommons.proxies.Response chatCompletions_Execute_WithHistory(IContext context, genaicommons.proxies.Request _request, genaicommons.proxies.Connection _connection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Request", _request == null ? null : _request.getMendixObject());
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		IMendixObject result = (IMendixObject)Core.microflowCall("SynthiaConnector.ChatCompletions_Execute_WithHistory").withParams(params).execute(context);
		return result == null ? null : genaicommons.proxies.Response.initialize(context, result);
	}
	/**
	 * Microflow can be used to invoke a chat completions API with a simple request where only a single user message is sent. If you want to send multiple historical user or assistant messages, use the ChatCompletions_Execute_WithHistory microflow.
	 * Inputs:
	 * - UserPrompt: This is the user input.
	 * - Request (optional): Contains messages and optional attributes.
	 * - Connection: Configuration object that contains endpoint and API key. The SynthiaConnection specialization pointing to a ConfigurationTextGeneration must be passed.
	 * - FileCollection (optional): Currently not supported by this operation!
	 */
	public static genaicommons.proxies.Response chatCompletions_Execute_WithoutHistory(IContext context, genaicommons.proxies.Connection _connection, java.lang.String _userPrompt, genaicommons.proxies.Request _request, genaicommons.proxies.FileCollection _fileCollection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		params.put("UserPrompt", _userPrompt);
		params.put("Request", _request == null ? null : _request.getMendixObject());
		params.put("FileCollection", _fileCollection == null ? null : _fileCollection.getMendixObject());
		IMendixObject result = (IMendixObject)Core.microflowCall("SynthiaConnector.ChatCompletions_Execute_WithoutHistory").withParams(params).execute(context);
		return result == null ? null : genaicommons.proxies.Response.initialize(context, result);
	}
	/**
	 * Use this operation to add chunks to a knowledge base. This operation handles a batch of chunks with their metadata in a single operation.
	 * 
	 * This operation takes care of the creation of the actual tables if needed. Duplications of chunks are not handled by this operation (neither when passing duplicates in the ChunkCollection nor checking an existing knowledge base prior to inserting).
	 * Use ChunkCollection_Create and ChunkCollection_AddKnowledgeBaseChunk to construct the input for this microflow, which needs to be passed as ChunkCollection.
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a Knowledgebase Configuration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base.
	 */
	public static boolean chunkCollection_Embed_Insert(IContext context, genaicommons.proxies.Connection _connection, genaicommons.proxies.ChunkCollection _chunkCollection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		params.put("ChunkCollection", _chunkCollection == null ? null : _chunkCollection.getMendixObject());
		return (java.lang.Boolean) Core.microflowCall("SynthiaConnector.ChunkCollection_Embed_Insert").withParams(params).execute(context);
	}
	/**
	 * Use this operation to replace existing chunks in a knowledge base based on the MxObjectID. This operation handles a batch of KnowledgebaseChunks in a ChunkCollection with their metadata in a single operation.
	 * Use ChunkCollection_Create and ChunkCollection_AddKnowledgeBaseChunk to construct the input for this microflow, which needs to be passed as a ChunkCollection.
	 * In order to replace the right data in the knowledge base, all chunks in ChunkCollection need a MxObjectID: existing chunks related to those Mendix objects will be deleted from the knowledge base first, and then be inserted according to the new state as specified by the ChunkCollection (metadata included).
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a Knowledgebase Configuration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base.
	 */
	public static boolean chunkCollection_Embed_Replace(IContext context, genaicommons.proxies.ChunkCollection _chunkCollection, genaicommons.proxies.Connection _connection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("ChunkCollection", _chunkCollection == null ? null : _chunkCollection.getMendixObject());
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		return (java.lang.Boolean) Core.microflowCall("SynthiaConnector.ChunkCollection_Embed_Replace").withParams(params).execute(context);
	}
	/**
	 * Use this operation to (re-)populate a whole knowledge base with a ChunkCollection.
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a Knowledgebase Configuration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base.
	 * 
	 * If the knowlege base already contains data, it will be removed before inserting the KnowledgeBaseChunks of the ChunkCollection.
	 */
	public static boolean chunkCollection_Embed_RepopulateKnowledgeBase(IContext context, genaicommons.proxies.Connection _connection, genaicommons.proxies.ChunkCollection _chunkCollection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		params.put("ChunkCollection", _chunkCollection == null ? null : _chunkCollection.getMendixObject());
		return (java.lang.Boolean) Core.microflowCall("SynthiaConnector.ChunkCollection_Embed_RepopulateKnowledgeBase").withParams(params).execute(context);
	}
	/**
	 * Converts the configuration string into a configuration object. 
	 * Overwrites an existing configuration with the same ID.
	 * 
	 * Can be used in microflows, for instance After Startup.
	 * 
	 * Throws an error if the input is not valid.
	 */
	public static void configuration_RegisterByString(IContext context, java.lang.String _configurationString)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("ConfigurationString", _configurationString);
		Core.microflowCall("SynthiaConnector.Configuration_RegisterByString").withParams(params).execute(context);
	}
	/**
	 * This operation takes a collection of text chunks and calculates an embedding vector with the model specified in the configuration for each chunk. 
	 * 
	 * It requires a GenAICommons.Connection object as well as a GenAICommons.ChunkCollection object connected to the collection of GenAICommons.Chunk objects as input and optionally a GenAICommons.EmbeddingsOptions object. A GenAICommons.EmbeddingsResponse object is being returned. 
	 * 
	 * The connection object should be created by using the microflow "SynthiaConnection_Create" with a configuration of type "Embeddings" or "Knowledge Base".
	 */
	public static genaicommons.proxies.EmbeddingsResponse embeddings_Execute_ChunkCollection(IContext context, genaicommons.proxies.Connection _connection, genaicommons.proxies.ChunkCollection _chunkCollection, genaicommons.proxies.EmbeddingsOptions _embeddingsOptions)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		params.put("ChunkCollection", _chunkCollection == null ? null : _chunkCollection.getMendixObject());
		params.put("EmbeddingsOptions", _embeddingsOptions == null ? null : _embeddingsOptions.getMendixObject());
		IMendixObject result = (IMendixObject)Core.microflowCall("SynthiaConnector.Embeddings_Execute_ChunkCollection").withParams(params).execute(context);
		return result == null ? null : genaicommons.proxies.EmbeddingsResponse.initialize(context, result);
	}
	/**
	 * This operation takes a single string and calculates an embedding vector with the model specified in the configuration for the InputText.
	 * 
	 * It requires a GenAICommons.Connection object as well as a string, optionally a GenAICommons.EmbeddingsOptions object. A GenAICommons.EmbeddingsResponse object is being returned. 
	 * 
	 * The connection object should be created by using the microflow "SynthiaConnection_Create" with a configuration of type "Embeddings" or "Knowledge Base".
	 */
	public static genaicommons.proxies.EmbeddingsResponse embeddings_Execute_String(IContext context, genaicommons.proxies.Connection _connection, java.lang.String _inputText, genaicommons.proxies.EmbeddingsOptions _embeddingsOptions)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		params.put("InputText", _inputText);
		params.put("EmbeddingsOptions", _embeddingsOptions == null ? null : _embeddingsOptions.getMendixObject());
		IMendixObject result = (IMendixObject)Core.microflowCall("SynthiaConnector.Embeddings_Execute_String").withParams(params).execute(context);
		return result == null ? null : genaicommons.proxies.EmbeddingsResponse.initialize(context, result);
	}
	/**
	 * Use this operation to delete a complete knowledge base at once. 
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a Knowledgebase Configuration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base.
	 */
	public static boolean knowledgeBase_Delete(IContext context, genaicommons.proxies.Connection _connection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		return (java.lang.Boolean) Core.microflowCall("SynthiaConnector.KnowledgeBase_Delete").withParams(params).execute(context);
	}
	/**
	 * Use this operation to get all knowledge bases that belong to a Knowledge Base Configuration. A list of type "KnowledgeBase" is returned.
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and a Knowledgebase Configuration associated with the connection details to the knowledge base service.
	 */
	public static java.util.List<synthiaconnector.proxies.KnowledgeBase> knowledgeBase_GetList(IContext context, genaicommons.proxies.Connection _connection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		java.util.List<IMendixObject> objs = Core.microflowCall("SynthiaConnector.KnowledgeBase_GetList").withParams(params).execute(context);
		if (objs == null) {
			return null;
		} else {
			return objs.stream()
				.map(obj -> synthiaconnector.proxies.KnowledgeBase.initialize(context, obj))
				.collect(java.util.stream.Collectors.toList());
		}
	}
	/**
	 * Use this operation to retrieve chunks from the knowledge base. The retrieval is based on similarity with respect to the input string (Content) provided.  This operation returns a list of KnowledgeBaseChunk. The returned list is sorted on vector similarity which is handled internally.
	 * Additional filtering can be done by specifying the optional input parameters:
	 * -MinimumSimilarity (in the range 0-1.0): acts as a cut-off: chunks are not retrieved if they have a similarity below this value.
	 * -MaxNumberOfResults: determines the max number of similar chunks that are returned.
	 * -MetadataCollection: when provided, this operation only returns chunks that are conform with all of the metadata key/value pairs in the collection.
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a KnowledgebaseConfiguration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base. 
	 * The TargetChunk entity (type parameter) must be a specialization of the KnowledgeBaseChunk entity from the GenAICommons. If it contains associations to (specializations of) the related mendix object for which the chunk was created originally, this will be set by this operation for easy processing afterwards.
	 */
	public static java.util.List<genaicommons.proxies.KnowledgeBaseChunk> knowledgeBaseChunkList_Embed_RetrieveNearestNeighbors(IContext context, java.lang.String _content, java.math.BigDecimal _minimumSimilarity, java.lang.Long _maxNumberOfResults, genaicommons.proxies.Connection _connection, genaicommons.proxies.MetadataCollection _metadataCollection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Content", _content);
		params.put("MinimumSimilarity", _minimumSimilarity);
		params.put("MaxNumberOfResults", _maxNumberOfResults);
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		params.put("MetadataCollection", _metadataCollection == null ? null : _metadataCollection.getMendixObject());
		java.util.List<IMendixObject> objs = Core.microflowCall("SynthiaConnector.KnowledgeBaseChunkList_Embed_RetrieveNearestNeighbors").withParams(params).execute(context);
		if (objs == null) {
			return null;
		} else {
			return objs.stream()
				.map(obj -> genaicommons.proxies.KnowledgeBaseChunk.initialize(context, obj))
				.collect(java.util.stream.Collectors.toList());
		}
	}
	/**
	 * Opens the configuration overview page to view and edit configurations.
	 */
	public static void nAV_ConfigurationOverview_Open(IContext context)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		Core.microflowCall("SynthiaConnector.NAV_ConfigurationOverview_Open").withParams(params).execute(context);
	}
	/**
	 * Creates a non-persistable connection that contains a configuration. This will be used as input for operations.
	 */
	public static synthiaconnector.proxies.SynthiaConnection synthiaConnection_Create(IContext context, synthiaconnector.proxies.Configuration _configuration, java.lang.String _knowledgeBaseName)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Configuration", _configuration == null ? null : _configuration.getMendixObject());
		params.put("KnowledgeBaseName", _knowledgeBaseName);
		IMendixObject result = (IMendixObject)Core.microflowCall("SynthiaConnector.SynthiaConnection_Create").withParams(params).execute(context);
		return result == null ? null : synthiaconnector.proxies.SynthiaConnection.initialize(context, result);
	}
}
