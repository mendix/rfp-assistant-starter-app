// This file was generated by Mendix Studio Pro.
//
// WARNING: Code you write here will be lost the next time you deploy the project.

package mxgenaiconnector.proxies.microflows;

import java.util.HashMap;
import java.util.Map;
import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;

public class Microflows
{
	/**
	 * @deprecated
	 * The default constructor of the Microflows class should not be used.
	 * Use the static microflow invocation methods instead.
	 */
	@java.lang.Deprecated(since = "9.12", forRemoval = true)
	public Microflows() {}

	// These are the microflows for the MxGenAIConnector module
	/**
	 * Use this operation to add chunks to a Collection. This operation handles a batch of chunks with their metadata in a single operation.
	 * 
	 * This operation takes care of the creation of the actual tables if needed. Duplications of chunks are not handled by this operation (neither when passing duplicates in the ChunkCollection nor checking an existing knowledge base prior to inserting).
	 * Use ChunkCollection_Create and ChunkCollection_AddKnowledgeBaseChunk to construct the input for this microflow, which needs to be passed as ChunkCollection.
	 * 
	 * The Connection entity passed must be of type MxKnowledgeBaseConnection and must contain the CollectionName string attribute filled and a MxCloudKnowledgeBase associated with the connection details to the knowledge base. By providing the CollectionName on the Connection, you determine the collection in which the chunks should be inserted.
	 * Use MxKnowledgeBaseConnection_Create to create it.
	 */
	public static boolean chunkCollection_Embed_Insert(IContext context, genaicommons.proxies.Connection _connection, genaicommons.proxies.ChunkCollection _chunkCollection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		params.put("ChunkCollection", _chunkCollection == null ? null : _chunkCollection.getMendixObject());
		return (java.lang.Boolean) Core.microflowCall("MxGenAIConnector.ChunkCollection_Embed_Insert").withParams(params).execute(context);
	}
	/**
	 * Use this operation to replace existing chunks in a Collection based on the MxObjectID. This operation handles a batch of KnowledgebaseChunks in a ChunkCollection with their metadata in a single operation.
	 * Use ChunkCollection_Create and ChunkCollection_AddKnowledgeBaseChunk to construct the input for this microflow, which needs to be passed as a ChunkCollection.
	 * In order to replace the right data in the collection, all chunks in ChunkCollection need a MxObjectID: existing chunks related to those Mendix objects will be deleted from the collection first, and then be inserted according to the new state as specified by the ChunkCollection (metadata included).
	 * 
	 * The Connection entity passed must be of type MxKnowledgeBaseConnection and must contain the CollectionName string attribute filled and a MxCloudKnowledgeBase associated with the connection details to the knowledge base service. By providing the CollectionName on the Connection, you determine the collection in which the chunks should be replaced.
	 * Use MxKnowledgeBaseConnection_Create to create it.
	 */
	public static boolean chunkCollection_Embed_Replace(IContext context, genaicommons.proxies.ChunkCollection _chunkCollection, genaicommons.proxies.Connection _connection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("ChunkCollection", _chunkCollection == null ? null : _chunkCollection.getMendixObject());
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		return (java.lang.Boolean) Core.microflowCall("MxGenAIConnector.ChunkCollection_Embed_Replace").withParams(params).execute(context);
	}
	/**
	 * Use this operation to (re-)populate a whole collection with a ChunkCollection.
	 * 
	 * The Connection entity passed must be of type MxKnowledgeBaseConnection and must contain the CollectionName string attribute filled and a MxCloudKnowledgeBase associated with the connection details to the knowledge base. By providing the CollectionName on the Connection, you determine the collection in which the chunks should be inserted.
	 * Use MxKnowledgeBaseConnection_Create to create it.
	 * 
	 * If the collection already contains data, it will be removed before inserting the KnowledgeBaseChunks of the ChunkCollection.
	 */
	public static boolean chunkCollection_Embed_RepopulateCollection(IContext context, genaicommons.proxies.Connection _connection, genaicommons.proxies.ChunkCollection _chunkCollection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		params.put("ChunkCollection", _chunkCollection == null ? null : _chunkCollection.getMendixObject());
		return (java.lang.Boolean) Core.microflowCall("MxGenAIConnector.ChunkCollection_Embed_RepopulateCollection").withParams(params).execute(context);
	}
	/**
	 * Use this operation to delete a complete collection at once. 
	 * 
	 * The Connection entity passed must be of type MxKnowledgeBaseConnection and must contain the CollectionName string attribute filled and a MxCloudKnowledgeBase associated with the connection details to the knowledge base service. By providing the CollectionName on the Connection, you determine the collection that is to be deleted. Use MxKnowledgeBaseConnection_Create to create this.
	 */
	public static boolean collection_Delete(IContext context, genaicommons.proxies.Connection _connection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		return (java.lang.Boolean) Core.microflowCall("MxGenAIConnector.Collection_Delete").withParams(params).execute(context);
	}
	/**
	 * Use this operation to get all collections that belong to a Knowledge Base Configuration. A list of type "Collection" is returned.
	 * 
	 * The Connection entity passed must be of type MxKnowledgeBaseConnection and a MxCloudKnowledgeBase associated with the connection details to the knowledge base service.
	 * Use MxKnowledgeBaseConnection_Create to create it.
	 */
	public static java.util.List<mxgenaiconnector.proxies.Collection> collection_GetList(IContext context, genaicommons.proxies.Connection _connection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		java.util.List<IMendixObject> objs = Core.microflowCall("MxGenAIConnector.Collection_GetList").withParams(params).execute(context);
		if (objs == null) {
			return null;
		} else {
			return objs.stream()
				.map(obj -> mxgenaiconnector.proxies.Collection.initialize(context, obj))
				.collect(java.util.stream.Collectors.toList());
		}
	}
	/**
	 * Converts the configuration string into a configuration object. 
	 * Overwrites an existing configuration with the same ID.
	 * 
	 * Can be used in microflows, for instance After Startup.
	 * 
	 * Returns false if the input is not valid and no object was created.
	 */
	public static mxgenaiconnector.proxies.Configuration configuration_RegisterByString(IContext context, java.lang.String _configurationStringImport)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("ConfigurationStringImport", _configurationStringImport);
		IMendixObject result = (IMendixObject)Core.microflowCall("MxGenAIConnector.Configuration_RegisterByString").withParams(params).execute(context);
		return result == null ? null : mxgenaiconnector.proxies.Configuration.initialize(context, result);
	}
	/**
	 * Use this operation to retrieve chunks from a collection. The retrieval is based on similarity with respect to the input string (Content) provided.  This operation returns a list of KnowledgeBaseChunk. The returned list is sorted on vector similarity which is handled internally.
	 * Additional filtering can be done by specifying the optional input parameters:
	 * -MinimumSimilarity (in the range 0-1.0): acts as a cut-off: chunks are not retrieved if they have a similarity below this value.
	 * -MaxNumberOfResults: determines the max number of similar chunks that are returned.
	 * -MetadataCollection: when provided, this operation only returns chunks that are conform with all of the metadata key/value pairs in the collection.
	 * 
	 * The Connection entity passed must be of type MxKnowledgeBaseConnection and must contain the CollectionName string attribute filled and a MxCloudKnowledgeBase associated with the connection details to the knowledge base. By providing the CollectionName on the Connection, you determine the collection for which the retrieve should happen. 
	 * Use MxKnowledgeBaseConnection_Create to create it.
	 * 
	 * The TargetChunk entity (type parameter) must be a specialization of the KnowledgeBaseChunk entity from the GenAICommons. If it contains associations to (specializations of) the related mendix object for which the chunk was created originally, this will be set by this operation for easy processing afterwards.
	 */
	public static java.util.List<genaicommons.proxies.KnowledgeBaseChunk> knowledgeBaseChunkList_Embed_RetrieveNearestNeighbors(IContext context, java.lang.String _content, java.math.BigDecimal _minimumSimilarity, java.lang.Long _maxNumberOfResults, genaicommons.proxies.Connection _connection, genaicommons.proxies.MetadataCollection _metadataCollection)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Content", _content);
		params.put("MinimumSimilarity", _minimumSimilarity);
		params.put("MaxNumberOfResults", _maxNumberOfResults);
		params.put("Connection", _connection == null ? null : _connection.getMendixObject());
		params.put("MetadataCollection", _metadataCollection == null ? null : _metadataCollection.getMendixObject());
		java.util.List<IMendixObject> objs = Core.microflowCall("MxGenAIConnector.KnowledgeBaseChunkList_Embed_RetrieveNearestNeighbors").withParams(params).execute(context);
		if (objs == null) {
			return null;
		} else {
			return objs.stream()
				.map(obj -> genaicommons.proxies.KnowledgeBaseChunk.initialize(context, obj))
				.collect(java.util.stream.Collectors.toList());
		}
	}
	/**
	 * Creates a non-persistable connection that contains a configuration with the connection details for the MxCloudKnowledgeBase. This will be used as input for operations that perform knowledge base interactions. The CollectionName is the name of the collection for which the knowledge base interactions should happen.
	 */
	public static mxgenaiconnector.proxies.MxKnowledgeBaseConnection mxKnowledgeBaseConnection_Create(IContext context, mxgenaiconnector.proxies.MxCloudKnowledgeBase _mxCloudKnowledgeBase, java.lang.String _collectionName)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("MxCloudKnowledgeBase", _mxCloudKnowledgeBase == null ? null : _mxCloudKnowledgeBase.getMendixObject());
		params.put("CollectionName", _collectionName);
		IMendixObject result = (IMendixObject)Core.microflowCall("MxGenAIConnector.MxKnowledgeBaseConnection_Create").withParams(params).execute(context);
		return result == null ? null : mxgenaiconnector.proxies.MxKnowledgeBaseConnection.initialize(context, result);
	}
	/**
	 * Opens the configuration overview page to view and edit configurations.
	 */
	public static void nAV_ConfigurationOverview_Open(IContext context)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		Core.microflowCall("MxGenAIConnector.NAV_ConfigurationOverview_Open").withParams(params).execute(context);
	}
	/**
	 * This action can be used to add an optional tool for Retrieve and Generate. If the Request is passed to the chat completions operation, the model can call this tool to retrieve data from the knowledge base and use it to generate a response. This works for with and without history cases. Multiple tools can be added at once (e.g., for different knowledge bases).
	 * 
	 * If an error occurs, it gets logged and the return object is empty.
	 */
	public static genaicommons.proxies.KnowledgeBaseRetrieval request_AddKnowledgeBaseTool(IContext context, genaicommons.proxies.Request _request, mxgenaiconnector.proxies.MxCloudKnowledgeBase _mxCloudKnowledgeBase, java.lang.String _collectionName, java.lang.Long _maxNumberOfResults, java.math.BigDecimal _minimumSimilarity, genaicommons.proxies.MetadataCollection _metadataCollection, java.lang.String _name, java.lang.String _description)
	{
		Map<java.lang.String, Object> params = new HashMap<>();
		params.put("Request", _request == null ? null : _request.getMendixObject());
		params.put("MxCloudKnowledgeBase", _mxCloudKnowledgeBase == null ? null : _mxCloudKnowledgeBase.getMendixObject());
		params.put("CollectionName", _collectionName);
		params.put("MaxNumberOfResults", _maxNumberOfResults);
		params.put("MinimumSimilarity", _minimumSimilarity);
		params.put("MetadataCollection", _metadataCollection == null ? null : _metadataCollection.getMendixObject());
		params.put("Name", _name);
		params.put("Description", _description);
		IMendixObject result = (IMendixObject)Core.microflowCall("MxGenAIConnector.Request_AddKnowledgeBaseTool").withParams(params).execute(context);
		return result == null ? null : genaicommons.proxies.KnowledgeBaseRetrieval.initialize(context, result);
	}
}
